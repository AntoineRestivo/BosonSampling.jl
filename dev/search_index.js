var documenterSearchIndex = {"docs":
[{"location":"types/partitions.html","page":"partitions","title":"partitions","text":"Modules = [BosonSampling]\nPages = [\"types/partitions.jl\"]\nPrivate = false","category":"page"},{"location":"types/partitions.html#BosonSampling.ModeOccupation","page":"partitions","title":"BosonSampling.ModeOccupation","text":"ModeOccupation(state)\n\nfields:         - n::Int         - m::Int         - state::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.Partition","page":"partitions","title":"BosonSampling.Partition","text":"Partition(subsets::Vector{Subset})\n\nCreate a partition from multiple Subset.\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.PartitionOccupancy","page":"partitions","title":"BosonSampling.PartitionOccupancy","text":"PartitionOccupancy(counts::ModeOccupation, n::Int, partition::Partition)\n\nFields:         - counts::ModeOccupation         - partition::Partition         - n::Int         - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.Subset","page":"partitions","title":"BosonSampling.Subset","text":"Subset(state::Vector{Int})\n\nCreate a mode occupation list with at most one count per mode.\n\nFields:         - n::Int         - m::Int         - subset::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.first_modes-Tuple{Int64, Int64}","page":"partitions","title":"BosonSampling.first_modes","text":"first_modes(n::Int, m::Int)\n\nCreate a ModeOccupation with n photons in the first sites of m modes.\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.occupies_all_modes-Tuple{Partition}","page":"partitions","title":"BosonSampling.occupies_all_modes","text":"occupiesallmodes(part::Partition)\n\nCheck wether a partition occupies all modes or not.\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.partition_from_subset_lengths-Tuple{Any}","page":"partitions","title":"BosonSampling.partition_from_subset_lengths","text":"partitionfromsubsetlengths(subsetlengths)\n\nReturn a partition from a vector of subset lengths.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/optimization.html#Optimization","page":"optimization","title":"Optimization","text":"","category":"section"},{"location":"tutorial/optimization.html","page":"optimization","title":"optimization","text":"An interesting question in BosonSampling is to find interferometers that of maximize certain properties.","category":"page"},{"location":"tutorial/optimization.html","page":"optimization","title":"optimization","text":"We provide the function minimize_over_unitary_matrices() which operates a conjugate gradient algorithm for the optimization over unitary matrices. It is implemented from Conjugate gradient algorithm for optimization under unitary matrix constraint from Traian Abrudan, Jan Eriksson, Visa Koivunen.","category":"page"},{"location":"functions/bayesian.html","page":"certification","title":"certification","text":"Modules = [BosonSampling]\nPages = [\"bayesian.jl\"]\nPrivate = false","category":"page"},{"location":"types/input.html","page":"inputs","title":"inputs","text":"Modules = [BosonSampling]\nPages = [\"input.jl\"]\nPrivate = false","category":"page"},{"location":"types/input.html#BosonSampling.Bosonic","page":"inputs","title":"BosonSampling.Bosonic","text":"Type used to notify that the input is made of FockState indistiguishable photons.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Distinguishable","page":"inputs","title":"BosonSampling.Distinguishable","text":"Model of distinguishable photons FockState.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.GramMatrix","page":"inputs","title":"BosonSampling.GramMatrix","text":"GramMatrix{T}(n::Int) where {T<:InputType}\nGramMatrix{T}(n::Int, distinguishability_param::Real) where {T<:InputType}\nGramMatrix{T}(n::Int, S::Matrix) where {T<:InputType}\n\nMatrix of partial distinguishability. Will automatically generate the proper matrix related to the provided InputType.\n\nFields:\n    - n::Int: photons number\n    - S::Matrix: Gram matrix\n    - rank::Union{Int, Nothing}\n    - distinguishability_param::Union{Real, Nothing}\n    - generating_vectors::OrthonormalBasis\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Input","page":"inputs","title":"BosonSampling.Input","text":"Input{T<:InputType}\nInput{T}(r::ModeOccupation) where {T<:InputType}\nInput{T}(r::ModeOccupation, G::GramMatrix) where {T<:InputType}\n\nInput state at the entrance of the interferometer.\n\nFields:\n    - r::ModeOccupation\n    - n::Int\n    - m::Int: modes numbers\n    - G::GramMatrix\n    - distinguishability_param::Union{Real, Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.InputType","page":"inputs","title":"BosonSampling.InputType","text":"Supertype to any concrete input type such as Bosonic, PartDist, Distinguishable and Undef.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.OneParameterInterpolation","page":"inputs","title":"BosonSampling.OneParameterInterpolation","text":"One parameter model of partial distinguishability interpolating between indistinguishable and fully distinguishable photons FockState.\n\nnote: Reference\nSampling of partially distinguishable bosons and the relation to the multidimensional permanent\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.OrthonormalBasis","page":"inputs","title":"BosonSampling.OrthonormalBasis","text":"OrthonormalBasis(vector_matrix::Union{Matrix, Nothing})\n\nBasis of vectors v_1v_n stored as columns in a n-by-r matrix possibly empty.\n\nFields:\n    vectors_matrix::Union{Matrix,Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.PartDist","page":"inputs","title":"BosonSampling.PartDist","text":"Type used to notify that the input is made of FockState partially distinguishable photons.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.RandomGramMatrix","page":"inputs","title":"BosonSampling.RandomGramMatrix","text":"Model of partially distinguishable photons FockState described by a randomly generated GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Undef","page":"inputs","title":"BosonSampling.Undef","text":"Model of photons FockState with undefined GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.UserDefinedGramMatrix","page":"inputs","title":"BosonSampling.UserDefinedGramMatrix","text":"Model of partially distinguishable photons FockState described by a provided GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"functions/proba_tools.html","page":"tools","title":"tools","text":"Modules = [BosonSampling]\nPages = [\"proba_tools.jl\"]\nPrivate = false","category":"page"},{"location":"functions/proba_tools.html#BosonSampling.clean_pdf","page":"tools","title":"BosonSampling.clean_pdf","text":"clean_pdf(A::Array, atol=ATOL)\n\nCheck wether an array is an acceptable discrete probability distribution with tolerance ATOL. If so, converts its elements to normalized positive real numbers.\n\n\n\n\n\n","category":"function"},{"location":"functions/proba_tools.html#BosonSampling.clean_proba","page":"tools","title":"BosonSampling.clean_proba","text":"clean_proba_(probability:Number, atol=ATOL)\n\nCheck wether a (complex) number is close enough to a valid probability with tolerance ATOL. If so, convert it to a positive real number.\n\n\n\n\n\n","category":"function"},{"location":"functions/proba_tools.html#BosonSampling.isa_pdf-Tuple{Any}","page":"tools","title":"BosonSampling.isa_pdf","text":"isa_pdf(pdf)\n\nAssert if pdf\tis a valid probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"functions/proba_tools.html#BosonSampling.sqr-Tuple{Any, Any}","page":"tools","title":"BosonSampling.sqr","text":"sqr(a,b)\n\nCompute the euclidian distance between two probability distributions.\t\n\n\n\n\n\n","category":"method"},{"location":"functions/proba_tools.html#BosonSampling.tvd-Tuple{Any, Any}","page":"tools","title":"BosonSampling.tvd","text":"tvd(a,b)\n\nCompute the total variation distance between two probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"intro.html#BosonSampling","page":"BosonSampling","title":"BosonSampling","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"This project implements standard and scattershot BosonSampling in Julia, including boson samplers and certification tools.","category":"page"},{"location":"intro.html#Conventions","page":"BosonSampling","title":"Conventions","text":"","category":"section"},{"location":"intro.html#Basic-conventions-:","page":"BosonSampling","title":"Basic conventions :","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"Photon creation operators are changed as   a_j - sum_j U_jk b_k   when going through the interferometer opU.   Thus, the rows correspond to the input, columns to the output, that is: the probability that a single goes from j to k is U_jk^2","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"This is the conventions used by most people. Let us warn that Valery Shchesnovich uses a convention that is incompatible: opU needs to be changed to opU^dagger. (And likewise defines the Gram matrix as the transpose of ours, see below.)","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"By default, we will use Tichy's conventions","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"Input vector = r or input_state\nOutput vector = s or output_state\nFor detection that if not just an event output_measurement\ninterferometer matrix = U\ninterferometer matrix M of Tichy (with rows corresponding to the input,...) = scattering_matrix\ndimension of the interferometer = m (size of the interferometer) or (n in previous code","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"or where the number of photons is irrelevant or called number_photons)","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"number of modes occupied = n, number_photons","category":"page"},{"location":"intro.html#Bunching","page":"BosonSampling","title":"Bunching","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"The H-matrix follows a convention different from that of Valery Shchesnovich: H_{a,b} = \\sum _{l \\in \\mathcal{K}} U_{l,a} U_{l,b}^{*}.","category":"page"},{"location":"intro.html#Conventions-regarding-Julia:","page":"BosonSampling","title":"Conventions regarding Julia:","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"Unlike most languages, the counting goes from 1,2,3... instead of starting at   zero as 0,1,2,...","category":"page"},{"location":"intro.html#Gram-matrices-:","page":"BosonSampling","title":"Gram matrices :","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"Gram matrices are defined as (phi_iphi_j) ij = 1n. This means that if the label of the photons are swapped, you need to enter another distinguishability matrix with   swapped labels accordingly.","category":"page"},{"location":"intro.html#Warning-about-precision-:","page":"BosonSampling","title":"Warning about precision :","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"in EventProbability :","category":"page"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"precision is set to machine precision eps() when doing non-randomised methods   although it is of course larger and this should be implemented   with permanent approximations, see for instance   https://arxiv.org/abs/1904.06229","category":"page"},{"location":"intro.html#Distances-:","page":"BosonSampling","title":"Distances :","text":"","category":"section"},{"location":"intro.html","page":"BosonSampling","title":"BosonSampling","text":"Beware of the different TVD conventions (1/2 in front or not)","category":"page"},{"location":"about.html#About","page":"About","title":"About","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"This project implements standard and scattershot BosonSampling in Julia, including boson samplers and certification tools.","category":"page"},{"location":"about.html#Conventions","page":"About","title":"Conventions","text":"","category":"section"},{"location":"about.html#Basic-conventions:","page":"About","title":"Basic conventions:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Photon creation operators are changed as a_j right_arrow sum_j U_jk b_k   when going through the interferometer opU.   Thus, the rows correspond to the input, columns to the output, that is: the probability that a single goes from j to k is U_jk^2","category":"page"},{"location":"about.html","page":"About","title":"About","text":"This is the conventions used by most people. Let us warn that Valery Shchesnovich uses a convention that is incompatible: opU needs to be changed to opU^dagger. (And likewise defines the Gram matrix as the transpose of ours, see below.)","category":"page"},{"location":"about.html","page":"About","title":"About","text":"By default, we will use Tichy's conventions","category":"page"},{"location":"about.html","page":"About","title":"About","text":"Input vector = r or input_state\nOutput vector = s or output_state\nFor detection that if not just an event output_measurement\ninterferometer matrix = U\ninterferometer matrix M of Tichy (with rows corresponding to the input,...) = scattering_matrix\ndimension of the interferometer = m (size of the interferometer) or (n in previous code","category":"page"},{"location":"about.html","page":"About","title":"About","text":"or where the number of photons is irrelevant or called number_photons)","category":"page"},{"location":"about.html","page":"About","title":"About","text":"number of modes occupied = n, number_photons","category":"page"},{"location":"about.html#Bunching:","page":"About","title":"Bunching:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"The H-matrix follows a convention different from that of Valery Shchesnovich: H_ab = sum _l in mathcalK U_la U_lb^*.","category":"page"},{"location":"about.html#Conventions-regarding-Julia:","page":"About","title":"Conventions regarding Julia:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Unlike most languages, the counting goes from 1,2,3... instead of starting at   zero as 0,1,2,...","category":"page"},{"location":"about.html#Gram-matrices:","page":"About","title":"Gram matrices:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Gram matrices are defined as (phi_iphi_j) ij = 1n. This means that if the label of the photons are swapped, you need to enter another distinguishability matrix with   swapped labels accordingly.","category":"page"},{"location":"about.html#Warning-about-precision:","page":"About","title":"Warning about precision:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"in EventProbability:","category":"page"},{"location":"about.html","page":"About","title":"About","text":"precision is set to machine precision eps() when doing non-randomised methods   although it is of course larger and this should be implemented   with permanent approximations, see for instance   https://arxiv.org/abs/1904.06229.","category":"page"},{"location":"about.html#Distances:","page":"About","title":"Distances:","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Beware of the different TVD conventions (1/2 in front or not).","category":"page"},{"location":"about.html#Related-package","page":"About","title":"Related package","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"The present package takes advantage of efficient computation of matrix permanent from Permanents.jl.  ","category":"page"},{"location":"about.html#Authors-and-License","page":"About","title":"Authors & License","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Benoît Seron\nAntoine Restivo","category":"page"},{"location":"about.html","page":"About","title":"About","text":"BosonSampling.jl is licensied under the MIT license.","category":"page"},{"location":"functions/samplers.html","page":"samplers","title":"samplers","text":"Modules = [BosonSampling]\nPages = [\"_sampler.jl\"]\nPrivate = false","category":"page"},{"location":"functions/samplers.html#BosonSampling.classical_sampler-Tuple{Any, Any, Any}","page":"samplers","title":"BosonSampling.classical_sampler","text":"classical_sampler(U, n, m)\nclassical_sampler(;input::Input, interf::Interferometer)\n\nSample photons according to the Distinguishable case.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.cliffords_sampler-Tuple{}","page":"samplers","title":"BosonSampling.cliffords_sampler","text":"cliffords_sampler(;input::Input, interf::Interferometer)\n\nSample photons according to the Bosonic case following Clifford & Clifford algorithm performed (at most) in O(n2^m + Poly(nm)) time and O(m) space.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.metropolis_sampler-Tuple{}","page":"samplers","title":"BosonSampling.metropolis_sampler","text":"metropolis_sampler(;target_pdf, known_pdf, known_sampler, starting_state, n_iter, n_burn = 100, n_thinning = 100)\n\nImplement a metropolis independent sampler for standard boson sampling following. The burn in period n_burnand the thinning interval n_thinning both have default value of 100.\n\nnote: Reference\nhttps://arxiv.org/abs/1705.00686: As the paper is limited to collinionless events, we keep track of this thanks to iterate_until_collisionless.\n\nwarning: Warning\nBurn in perdiod and thinning interval must have the same value.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.noisy_sampler-Tuple{}","page":"samplers","title":"BosonSampling.noisy_sampler","text":"noisy_sampler(;input::Input, reflectivity::Real, interf::Interferometer)\n\nSample partially-distinguishable photons through a lossy interferometer, which runs (at most) in O(n2^m + Poly(nm)) time.\n\nnote: Reference\nhttps://arxiv.org/pdf/1907.00022.pdf\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html","page":"scattering","title":"scattering","text":"Modules = [BosonSampling]\nPages = [\"scattering.jl\"]\nPrivate = false","category":"page"},{"location":"functions/scattering.html#BosonSampling.at_most_one_photon_per_bin-Tuple{Vector{Int64}}","page":"scattering","title":"BosonSampling.at_most_one_photon_per_bin","text":"at_most_one_photon_per_bin(occupancy_vector::Vector{Int})\ncheck_at_most_one_particle_per_mode(occ)\n\nCheck wether occupancy_vector contains more than one photon per site.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.bosonic_amplitude","page":"scattering","title":"BosonSampling.bosonic_amplitude","text":"bosonic_amplitude(U, input_state, output_state, permanent=ryser)\nprocess_amplitude(U, input_state, output_state, permanent=ryser)\n\nCompute the probability amplitude to go from input_state to output_state through the interferomter U in the Bosonic case.\n\n\n\n\n\n","category":"function"},{"location":"functions/scattering.html#BosonSampling.bosonic_probability-Tuple{Any, Any, Any}","page":"scattering","title":"BosonSampling.bosonic_probability","text":"bosonic_probability(U, input_state, output_state)\nprocess_probability(U, input_state, output_state)\n\nCompute the probability to go from input_state to output_state through the interferometer U in the Bosonic case.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.check_suppression_law-Tuple{Any}","page":"scattering","title":"BosonSampling.check_suppression_law","text":"check_suppression_law(event)\n\nCheck if the event is suppressed according to the rule.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.distinguishable_probability","page":"scattering","title":"BosonSampling.distinguishable_probability","text":"distinguishable_probability(U, input_state, output_state, permanent=ryser)\nprocess_probability_distinguishable(U, input_state, output_state, permanent=ryser)\n\nCompute the probability to go from input_state to output_state through the interferomter U in the Distinguishable case.\n\n\n\n\n\n","category":"function"},{"location":"functions/scattering.html#BosonSampling.fill_arrangement-Tuple{Any}","page":"scattering","title":"BosonSampling.fill_arrangement","text":"fill_arrangement(occupation_vector)\nfill_arrangement(r::ModeOccupation)\nfill_arrangement(input::Input)\n\nConvert a mode occupation list to a mode assignement.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.iterate_until_collisionless-Tuple{Any}","page":"scattering","title":"BosonSampling.iterate_until_collisionless","text":"iterate_until_collisionless(f)\n\nSample f until the result is collisionless.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.occupancy_vector_to_partition-Tuple{Any}","page":"scattering","title":"BosonSampling.occupancy_vector_to_partition","text":"occupancy_vector_to_partition(occupancy_vector)\noccupancy_vector_to_mode_occupancy(occupancy_vector)\n\nReturn a partition of occupied modes from an occupancy_vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.output_mode_occupation-Tuple{Any, Any}","page":"scattering","title":"BosonSampling.output_mode_occupation","text":"output_mode_occupation(n::Int, m::Int)\n\nReturn all possible configurations of n photons among m modes.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.process_probability_partial-NTuple{4, Any}","page":"scattering","title":"BosonSampling.process_probability_partial","text":"process_probability_partial(U, S, input_state, output_state)\nprocess_probability_partial(interf::Interferometer, input_state::Input{TIn} where {TIn<:PartDist},output_state::FockDetection)\n\nCompute the probability to go from input_state to output_state through the interferometer U in the PartDist case where partial distinguishable is described by the GramMatrix S.\n\nnote: Reference\nhttps://arxiv.org/abs/1410.7687\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_mode_occupation-Tuple{Int64, Int64}","page":"scattering","title":"BosonSampling.random_mode_occupation","text":"random_mode_occupation(n::Int, m::Int)\n\nCreate a ModeOccupation from a mode occupation list of n ramdomly placed ones among m sites.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_mode_occupation_collisionless-Tuple{Int64, Int64}","page":"scattering","title":"BosonSampling.random_mode_occupation_collisionless","text":"random_mode_occupation_collisionless(n::Int, m::Int)\n\nCreate a ModeOccupation from a random mode occupation that is likely collisionless.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_occupancy-Tuple{Int64, Int64}","page":"scattering","title":"BosonSampling.random_occupancy","text":"random_occupancy(n::Int, m::Int)\n\nReturn a vector of size m\twith n randomly placed ones.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.scattering_matrix-Tuple{Matrix, Vector{Int64}, Vector{Int64}}","page":"scattering","title":"BosonSampling.scattering_matrix","text":"scattering_matrix(U::Matrix, input_state::Vector{Int}, output_state::Vector{Int})\nscattering_matrix(U::Interferometer, r::ModeOccupation, s::ModeOccupation)\nscattering_matrix(U::Interferometer, i::Input, o::FockDetection)\n\nReturn the submatrix of U whose rows and columns are respectively defined by input_state and output_state.\n\nnote: Reference\nhttp://arxiv.org/abs/quant-ph/0406127v1\n\n\n\n\n\n","category":"method"},{"location":"tutorial/permanent_conjectures.html#Permanent-conjectures","page":"permanent conjectures","title":"Permanent conjectures","text":"","category":"section"},{"location":"tutorial/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"Permanent and generalized matrix functions conjectures are linked to interesting and practical properties of boson samplers, as emphasized for instance by V. S. Shchesnovich in Universality of Generalized Bunching and Efficient Assessment of Boson Sampling as well as in the author's work Boson bunching is not maximized by indistinguishable particles.","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"To search for new counter examples of a conjecture, one can implement a user-defined search_function(). For instance, random_search_counter_example_bapat_sunder searches for counter examples of the Bapat-Sunder conjecture (see also violates_bapat_sunder) in a brute-force manner, trying a different random set of matrices at each call. One can then use","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"search_until_user_stop(search_function)","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"which will iterate the function until you press Ctrl+C to interrupt the computation.","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"Another important conjecture is the permaent-on-top conjecture, disproved by V. S. Shchesnovich in The permanent-on-top conjecture is false. Special matrices related to this conjecture are given in this package such as the schur_matrix(H), the general partial distinguishability function J(σ) implemented as J_array. From a matrix J, one can recover the density matrix of the internal states with density_matrix_from_J.","category":"page"},{"location":"functions/bunching.html","page":"bunching","title":"bunching","text":"Modules = [BosonSampling]\nPages = [\"bunching.jl\"]\nPrivate = false","category":"page"},{"location":"functions/bunching.html#BosonSampling.H_matrix-Tuple{Any, Vector, Vector}","page":"bunching","title":"BosonSampling.H_matrix","text":"H_matrix(U, input_state, partition_occupancy_vector)\nH_matrix(interf::Interferometer, i::Input, o::FockDetection)\nH_matrix(interf::Interferometer, i::Input, subset_modes::ModeOccupation)\n\nH matrix for a partition defined by partition_occupancy_vector, see definition in the article below.\n\nnote: Note\nConventions follow the author's Boson bunching is not maximized by indistinguishable particles which are the ones compatible with Tichy's conventions (Shshnovitch has a different one for the evolution of the creation operators).\n\n\n\n\n\n","category":"method"},{"location":"functions/bunching.html#BosonSampling.bunching_probability_brute_force_bosonic-Tuple{Any, Any, Any}","page":"bunching","title":"BosonSampling.bunching_probability_brute_force_bosonic","text":"bunching_probability_brute_force_bosonic(U, input_state, output_state; print_output = false)\nbunching_probability_brute_force_bosonic(interf::Interferometer, i::Input, subset_modes::ModeOccupation)\n\nBosonic bunching probability by direct summation of all possible cases\n\nbunching_event_proba gives the probability to get the event of 1^n 0^(m-n).\n\n\n\n\n\n","category":"method"},{"location":"functions/bunching.html#BosonSampling.full_bunching_probability-Tuple{Interferometer, Input, Subset}","page":"bunching","title":"BosonSampling.full_bunching_probability","text":"full_bunching_probability(interf::Interferometer, i::Input, subset_modes::Subset)\nfull_bunching_probability(interf::Interferometer, i::Input, mo::ModeOccupation)\n\nComputes the probability that all n photons end up in the subset of chosen output modes following.\n\nnote: Reference\nUniversality of Generalized Bunching and Efficient Assessment of Boson Sampling\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html","page":"partitions","title":"partitions","text":"Modules = [BosonSampling]\nPages = [\"legacy.jl\", \"partition_expectation_values.jl\", \"partitions/partitions.jl\"]\nPrivate = false","category":"page"},{"location":"functions/partitions.html#BosonSampling.matrix_phi-NTuple{4, Any}","page":"partitions","title":"BosonSampling.matrix_phi","text":"matrix_phi(k, U, occupancy_vector, n)\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.partition_probability_distribution_distinguishable_rand_walk-Tuple{Any, Any}","page":"partitions","title":"BosonSampling.partition_probability_distribution_distinguishable_rand_walk","text":"partition_probability_distribution_distinguishable_rand_walk(part, U)\n\nGenerate a vector giving the probability to have k photons in the partition part at the output of the interferomter U.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.proba_partition_bosonic-Tuple{}","page":"partitions","title":"BosonSampling.proba_partition_bosonic","text":"proba_partition_bosonic(;U, occupancy_vector, input_state=ones(Int, size(U,1)), checks=true)\n\nIndistinguishable version of proba_partition_partial.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.proba_partition_partial-Tuple{}","page":"partitions","title":"BosonSampling.proba_partition_partial","text":"proba_partition_partial(;U, S, occupancy_vector, input_state, checks=true)\n\nReturn a n+1 sized array giving the probability to find [0,1,...], photons inside the bins given by occupancy_vector at the output of U.\n\nnote: Note\nWe take U of dimension m while M is the scattering matrix, as in Tichy, M_ij = U_d_i _d_j.\nGiven n photons, generally in the first modes, the distinguishability matrix is defined as in Tichy, S_ij = phi_d_iphi_d_j. This is not a problem as it does not depend on the output partition but be aware of it.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.best_partition_size-Tuple{}","page":"partitions","title":"BosonSampling.best_partition_size","text":"best_partition_size(;m, n, n_subsets, distance=tvd)\n\nReturn the ideal partition_size_vector for a given number of subsets n_subsets and the Haar averaged TVD in second parameter.\n\nnote: Note\nFor a single subset, n_subsets=2 as we need a complete partition, occupying all modes.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.choose_best_average_subset-Tuple{}","page":"partitions","title":"BosonSampling.choose_best_average_subset","text":"choose_best_average_subset(;m, n, distance=tvd)\n\nReturn the ideal subset size on average and its total variance distance.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.partition_expectation_values-Tuple{Any, Any}","page":"partitions","title":"BosonSampling.partition_expectation_values","text":"partition_expectation_values(partition_size_vector, partition_counts)\npartition_expectation_values(part_occ::PartitionOccupancy)\n\nReturn the Haar averaged probability of photon number count in binned outputs for Distinguishable and Bosonic particles.\n\nnote: Reference\n[https://www.nature.com/articles/s41598-017-00044-8.pdf](https://www.nature.com/articles/s41598-017-00044-8.pdf)\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.subset_expectation_value-NTuple{4, Any}","page":"partitions","title":"BosonSampling.subset_expectation_value","text":"subset_expectation_value(subset_size, k, n, m)\n\nReturn the Haar averaged probability to find k from n photons inside a subset of binned output modes of length size_subset among m modes for Distinguishable and Bosonic cases.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.subset_relative_distance_of_averages-Tuple{Any, Any, Any}","page":"partitions","title":"BosonSampling.subset_relative_distance_of_averages","text":"subset_relative_distance_of_averages(subset_size, n, m)\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.all_mode_configurations-Tuple{Any, Any}","page":"partitions","title":"BosonSampling.all_mode_configurations","text":"allmodeconfigurations(n, nsubset; onlyphotonnumberconserving=false)    allmodeconfigurations(inputstate::Input, part::Partition; onlyphotonnumberconserving=false)    allmodeconfigurations(inputstate::Input, sub::Subset; onlyphotonnumberconserving=false)\n\nGenerate all possible photon counts of n photons in a partition/subset of n_subset subsets.\n\nnote: Note\nDoes not take into account photon number conservation by default\nThis is the photon counting in partitions and not events outputs but it can be used likewise\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.check_photon_conservation-Tuple{Any, Any, Any}","page":"partitions","title":"BosonSampling.check_photon_conservation","text":"checkphotonconservation(physicalindexes,  pdf, n; atol=ATOL, partitionspansallmodes=false)\n\nCheck if probabilities corresponding to non photon number conserving events are zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probabilities_partition-Tuple{Interferometer, Partition, Input}","page":"partitions","title":"BosonSampling.compute_probabilities_partition","text":"computeprobabilitiespartition(physicalinterferometer::Interferometer, part::Partition, inputstate::Input)\n\nCompute the probability to find a certain photon counts in a partition part of the output modes for the given interferometer.\n\nReturn `(counts = physical_indexes, probabilities = pdf) corresponding to the occupation numbers in the partition and the associated probability.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probability!-Union{Tuple{Event{TIn, TOut}}, Tuple{TOut}, Tuple{TIn}} where {TIn<:InputType, TOut<:PartitionCount}","page":"partitions","title":"BosonSampling.compute_probability!","text":"computeprobability!(ev::Event{TIn,TOut}) where {TIn<:InputType, TOut<:PartitionCount}    computeprobability!(ev::Event{TIn,TOut}) where {TIn<:InputType, TOut<:PartitionCountsAll}\n\nGiven a defined [Event], computes/updates its probability or set of probabilities (for instance if looking at partition outputs, with MultipleCounts begin filled).\n\nThis function is defined separately as it is most often the most time consuming step of calculations and one may which to separate the evaluation of probabilities from preliminary definitions.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probability_partition_occupancy-Tuple{Interferometer, PartitionOccupancy, Input}","page":"partitions","title":"BosonSampling.compute_probability_partition_occupancy","text":"computeprobabilitypartitionoccupancy(physicalinterferometer::Interferometer, partoccupancy::PartitionOccupancy, inputstate::Input)\n\nCompute the probability to find a partition occupancy.\n\nnote: Note\nInefficient to use multiple times for the same physical setting, rather use computeprobabilitiespartition.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.photon_number_conserving_events-Tuple{Any, Any}","page":"partitions","title":"BosonSampling.photon_number_conserving_events","text":"photonnumberconservingevents(physicalindexes, n; partitionspansall_modes=false)\n\nReturn only the events conserving photon number n.\n\nnote: Note\nIf partition_spans_all_modes=false, gives all events with less than n or n photons\nIf partition_spans_all_modes = true only exact photon number conserving physical_indexes\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.photon_number_non_conserving_events-Tuple{Any, Any}","page":"partitions","title":"BosonSampling.photon_number_non_conserving_events","text":"photonnumbernonconservingevents(physicalindexes, n; partitionspansallmodes=false)\n\nReturn the elements not conserving the number of photons.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.ranked_partition_list-Tuple{Any}","page":"partitions","title":"BosonSampling.ranked_partition_list","text":"rankedpartitionlist(part_list)\n\nRemove partitions such as [1,2] when [2,1] is already counted as only the size of the partition counts; only keeps vectors of decreasing count.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.remove_trivial_partitions!-Tuple{Any}","page":"partitions","title":"BosonSampling.remove_trivial_partitions!","text":"removetrivialpartitions!(part_list)\n\nIn a list of partitions sizes, ex. [[2,0],[1,1],[0,2]], keeps only the elements with non trivial subset size, in this ex. only [1,1].\n\n\n\n\n\n","category":"method"},{"location":"tutorial/installation.html#Installation","page":"installation","title":"Installation","text":"","category":"section"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"To install the package, launch a Julia REPL session and type","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"julia> using Pkg; Pkg.add(\"BosonSampling\")","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"Alternatively type on the ] key. Then enter","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"add BosonSampling","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"To use the package, write","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"using BosonSampling","category":"page"},{"location":"tutorial/installation.html","page":"installation","title":"installation","text":"in your file.","category":"page"},{"location":"types/events.html","page":"events","title":"events","text":"Modules = [BosonSampling]\nPages = [\"events.jl\"]\nPrivate = false","category":"page"},{"location":"types/events.html#BosonSampling.Event","page":"events","title":"BosonSampling.Event","text":"Event{TIn<:InputType, TOut<:OutputMeasurementType}\n\nEvent linking an input to an output.\n\nFields:\n\t- input_state::Input{TIn}\n\t- output_measurement::TOut\n\t- proba_params::EventProbability\n\t- interferometer::Interferometer\n\n\n\n\n\n","category":"type"},{"location":"types/events.html#BosonSampling.EventProbability","page":"events","title":"BosonSampling.EventProbability","text":"EventProbability(probability::Union{Nothing, Number})\nEventProbability(mc::MultipleCounts)\n\nHolds the probability or probabilities of an Event.\n\nFields:\n\t- probability::Union{Number,Nothing, MultipleCounts}\n\t- precision::Union{Number,Nothing}\n\t- failure_probability::Union{Number,Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/events.html#BosonSampling.MultipleCounts","page":"events","title":"BosonSampling.MultipleCounts","text":"MultipleCounts()\nMultipleCounts(counts, proba)\n\nHolds something like the photon counting probabilities with their respective probability (in order to use them as a single observation). Can be declared empty as a placeholder.\n\nFields:\n\t- counts::Union{Nothing, Vector{ModeOccupation}, Vector{PartitionOccupancy}},\n\t- proba::Union{Nothing,Vector{Real}}\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html","page":"interferomters","title":"interferomters","text":"Modules = [BosonSampling]\nPages = [\"interferometers.jl\"]\nPrivate = false","category":"page"},{"location":"types/interferometers.html#BosonSampling.BeamSplitter","page":"interferomters","title":"BosonSampling.BeamSplitter","text":"BeamSplitter(transmission_amplitude::Float64)\n\nCreates a beam-splitter with tunable transmissivity.\n\nFields:\n    - transmission_amplitude::Float64\n    - U::Matrix{ComplexF64}\n    - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Fourier","page":"interferomters","title":"BosonSampling.Fourier","text":"Fourier(m::Int)\n\nCreates a Fourier Interferometer of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Hadamard","page":"interferomters","title":"BosonSampling.Hadamard","text":"Hadamard(m::Int)\n\nCreates a Hadamard Interferometer of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Interferometer","page":"interferomters","title":"BosonSampling.Interferometer","text":"Supertype to any concrete interferomter type such as UserDefinedInterferometer, RandHaar, Fourier,...\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.PhaseShift","page":"interferomters","title":"BosonSampling.PhaseShift","text":"PhaseShift(shifted_modes::Array, param_::Array)\n\nCreates a phase-shifter that is applied on the modes precised by shiftedmodes with phase shifts given in param.\n\nFields:\n    - shifted_modes::Array\n    - param_::Array\n    - m::Int\n    - U::Matrix{ComplexF64}\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.RandHaar","page":"interferomters","title":"BosonSampling.RandHaar","text":"RandHaar(m::Int)\n\nCreates an instance of Interferometer from a Haar distributed unitary matrix of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Rotation","page":"interferomters","title":"BosonSampling.Rotation","text":"Rotation(angle::Float64)\n\nCreates a Rotation matrix with tunable angle.\n\nFields:\n    - angle::Float64\n    - U::Matrix{ComplexF64}\n    - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.UserDefinedInterferometer","page":"interferomters","title":"BosonSampling.UserDefinedInterferometer","text":"UserDefinedInterferometer(U::Matrix)\n\nCreates an instance of Interferometer from a given unitary matrix U.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"functions/special_matrices.html","page":"special_matrices","title":"special_matrices","text":"Modules = [BosonSampling]\nPages = [\"special_matrices.jl\"]\nPrivate = false","category":"page"},{"location":"functions/special_matrices.html#BosonSampling.fourier_matrix-Tuple{Int64}","page":"special_matrices","title":"BosonSampling.fourier_matrix","text":"fourier_matrix(n::Int; normalized=true)\n\nReturns a n-by-n Fourier matrix with optional normalization (true by default).\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.gram_matrix_one_param-Tuple{Int64, Real}","page":"special_matrices","title":"BosonSampling.gram_matrix_one_param","text":"gram_matrix_one_param(n::Int, x::Real)\n\nReturns a n-by-n Gram matrix parametrized by the real 0  x  1.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.hadamard_matrix","page":"special_matrices","title":"BosonSampling.hadamard_matrix","text":"hadamard_matrix(n::Int; normalized=true)\n\nReturns a n-by-n Hadamard matrix with optional normalization (true by default).\n\n\n\n\n\n","category":"function"},{"location":"functions/special_matrices.html#BosonSampling.perturbed_gram_matrix-Tuple{Any, Any}","page":"special_matrices","title":"BosonSampling.perturbed_gram_matrix","text":"perturbed_gram_matrix(M, epsilon)\n\nReturns a Gram matrix generated by the columns of M which are perturbed by a Gaussian quantity of variance epsilon once normalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.perturbed_unitary-Tuple{Any, Any}","page":"special_matrices","title":"BosonSampling.perturbed_unitary","text":"perturbed_unitary(U, epsilon)\n\nReturns a unitary matrix whose columns are generating vector perturbed by a random Gaussian quantity with variance epsilon once normalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix-Tuple{Int64}","page":"special_matrices","title":"BosonSampling.rand_gram_matrix","text":"rand_gram_matrix(n::Int)\n\nReturns a full rank n-by-n random Gram matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_from_orthonormal_basis-Tuple{Any, Any}","page":"special_matrices","title":"BosonSampling.rand_gram_matrix_from_orthonormal_basis","text":"rand_gram_matrix_from_orthonormal_basis(n::Int, r::Int)\n\nReturns a n-by-n random Gram matrix that generates orthonormal basis of r vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_positive-Tuple{Int64}","page":"special_matrices","title":"BosonSampling.rand_gram_matrix_positive","text":"rand_gram_matrix_positive(n::Int)\n\nReturns a positive elements n-by-n random Gram matrix of full rank.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_rank-Tuple{Any, Any}","page":"special_matrices","title":"BosonSampling.rand_gram_matrix_rank","text":"rand_gram_matrix_rank(n::Int, r::Int)\n\nReturns a n-by-n random Gram matrix of maximum rank and great likelihood r.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_real-Tuple{Any}","page":"special_matrices","title":"BosonSampling.rand_gram_matrix_real","text":"rand_gram_matrix_real(n::Int)\n\nReturns a real n-by-n random Gram matrix of full rank.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_haar-Tuple{Int64}","page":"special_matrices","title":"BosonSampling.rand_haar","text":"rand_haar(n::Int)\n\nReturns a n-by-n Haar distributed unitary matrix following https://case.edu/artsci/math/esmeckes/MeckesSAMSILecture2.pdf.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.sylvester_matrix-Tuple{Any}","page":"special_matrices","title":"BosonSampling.sylvester_matrix","text":"sylvester_matrix(p::Int; normalized=true)\n\nReturns a 2^p-by-2^p Sylvester matrix with optional normalization (true by default) following https://arxiv.org/abs/1502.06372.\n\n\n\n\n\n","category":"method"},{"location":"functions/visualize.html","page":"visualization","title":"visualization","text":"Modules = [BosonSampling]\nPages = [\"visual.jl\"]\nPrivate = false","category":"page"},{"location":"functions/visualize.html#BosonSampling.visualize_proba-Tuple{Input, Any, Any}","page":"visualization","title":"BosonSampling.visualize_proba","text":"visualize_proba(input::Input, output, data)\n\nDraw a schematic representation associated to the event with probability data.    \n\n\n\n\n\n","category":"method"},{"location":"functions/visualize.html#BosonSampling.visualize_sampling-Tuple{Input, Any}","page":"visualization","title":"BosonSampling.visualize_sampling","text":"visualize_sampling(input::Input, output)\n\nDraw a schematic representation of the setup.\n\n\n\n\n\n","category":"method"},{"location":"functions/distributions.html","page":"distributions","title":"distributions","text":"Modules = [BosonSampling]\nPages = [\"distribution.jl\"]\nPrivate = false","category":"page"},{"location":"functions/distributions.html#BosonSampling.noisy_distribution-Tuple{}","page":"distributions","title":"BosonSampling.noisy_distribution","text":"noisy_distribution(;input::Input, reflectivity::Real, interf::Interferometer, exact=true, approx=true, samp=true)\n\nCompute the exact and/or approximated and/or sampled probability distribution of all possible output configurations of partially-distinguishable photons through a lossy interferometer. By default, exact, approx and samp are set to true meaning that noisy_distribution returns an array containing the three distributions.\n\nnote: Note\nThe probabilities within a distribution are indexed following the same order as output_mode_occupation(n,m)\nThe approximated distribution has error and failure probability of 1e^-4.\n\nnote: Reference\nhttps://arxiv.org/pdf/1809.01953.pdf\n\n\n\n\n\n","category":"method"},{"location":"functions/distributions.html#BosonSampling.theoretical_distribution-Tuple{}","page":"distributions","title":"BosonSampling.theoretical_distribution","text":"theoretical_distribution(;input::Input, interf::Interferometer, i=nothing)\n\nCompute the probability distribution of all possible output configurations of fully/partially-indistinguishable photons through a lossless interferometer.\n\nnote: Note\nThe probabilities within the distribution are indexed following the same order as output_mode_occupation(n,m)\nIf i (with default value nothing) is set to an integer theoretical_distribution returns the probability to find the photons in the i'th configuration given by output_mode_occupation\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html","page":"permanent conjectures","title":"permanent conjectures","text":"Modules = [BosonSampling]\nPages = [\"bapat_sunder.jl\", \"counter_example_functions.jl\", \"counter_example_numerical_search.jl\", \"permanent_on_top.jl\"]\nPrivate = false","category":"page"},{"location":"functions/permanent_conjectures.html#BosonSampling.violates_bapat_sunder","page":"permanent conjectures","title":"BosonSampling.violates_bapat_sunder","text":"violates_bapat_sunder(A,B, tol = ATOL)\n\nChecks if matrices A and B violate the Bapat-Sunder conjecture, see Boson bunching is not maximized by indistinguishable particles\n\n\n\n\n\n","category":"function"},{"location":"functions/permanent_conjectures.html#BosonSampling.add_columns_to_make_square_unitary-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.add_columns_to_make_square_unitary","text":"add_columns_to_make_square_unitary(M_dagger)\n\nMakes a square matrix U of which the first columns are M_dagger, which has to be unitary by itself by a random choice of vectors that are then orthonormalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.cholesky_semi_definite_positive-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.cholesky_semi_definite_positive","text":"cholesky_semi_definite_positive(A)\n\ncholesky decomposition (A = R' * R) for a sdp but not strictly positive definite matrix\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.incorporate_in_a_unitary-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.incorporate_in_a_unitary","text":"incorporate_in_a_unitary(X)\n\nincorporates the renormalized matrix X in a double sized unitary through the proof of Lemma 29  of Aaronson Arkipov seminal The Computational Complexity of Linear Optics\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.incorporate_in_a_unitary_non_square-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.incorporate_in_a_unitary_non_square","text":"incorporate_in_a_unitary_non_square(X)\n\nsame as incorporate_in_a_unitary but for a matrix renormalized X of type (m,n) with m >= n generates a minimally sized unitary (ex 99 interferometer for the 72 M' of the first counter example of drury)\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.random_search_counter_example_bapat_sunder-Tuple{}","page":"permanent conjectures","title":"BosonSampling.random_search_counter_example_bapat_sunder","text":"random_search_counter_example_bapat_sunder(;m,n,r, physical_H = true)\n\nBrute-force search of counter-examples of rank r.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.search_until_user_stop-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.search_until_user_stop","text":"search_until_user_stop(search_function)\n\nRuns search_function until user-stop (Ctrl+C).\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.J_array-Tuple{Any, Any}","page":"permanent conjectures","title":"BosonSampling.J_array","text":"J_array(theta, n)\n\nreturns the J as defined in in Eq.10 of Universality of Generalized Bunching and Efficient Assessment of Boson Sampling, with the permutations coming in the order given by permutations(collect(1:n))\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.density_matrix_from_J-Tuple{Any, Any}","page":"permanent conjectures","title":"BosonSampling.density_matrix_from_J","text":"density_matrix_from_J(J,n)\n\ndensity matrix associated to a J function as defined in Universality of Generalized Bunching and Efficient Assessment of Boson Sampling, computed through Eq. 46.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.schur_matrix-Tuple{Any}","page":"permanent conjectures","title":"BosonSampling.schur_matrix","text":"schur_matrix(H)\n\ncomputes the Schur matrix as defined in Eq. 1 of Linear Algebra and its Applications 490 (2016) 196–201\n\n\n\n\n\n","category":"method"},{"location":"types/measurements.html","page":"measurements","title":"measurements","text":"Modules = [BosonSampling]\nPages = [\"measurements.jl\"]\nPrivate = false","category":"page"},{"location":"types/measurements.html#BosonSampling.FockDetection","page":"measurements","title":"BosonSampling.FockDetection","text":"FockDetection(s::ModeOccupation)\n\nMeasuring the probability of getting the ModeOccupation s at the output.\n\nFields:\n    - s::ModeOccupation\n\n\n\n\n\n","category":"type"},{"location":"types/measurements.html#BosonSampling.PartitionCount","page":"measurements","title":"BosonSampling.PartitionCount","text":"PartitionCount(part_occupancy::PartitionOccupancy)\n\nMeasuring the probability of getting a specific count for a given partition part_occupancy.\n\nFields:\n    - part_occupancy::PartitionOccupancy\n\n\n\n\n\n","category":"type"},{"location":"types/measurements.html#BosonSampling.PartitionCountsAll","page":"measurements","title":"BosonSampling.PartitionCountsAll","text":"PartitionCountsAll(part::Partition)\n\nMeasuring all possible counts probabilities in the partition part.\n\nFields:\n    - part::Partition\n\n\n\n\n\n","category":"type"},{"location":"index.html#BosonSampling.jl-Documentation","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"## About","category":"page"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"Pages = [\"about.md\"]","category":"page"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"## Library","category":"page"},{"location":"index.html#Types","page":"BosonSampling.jl Documentation","title":"Types","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"Pages = [\"input.md\", \"events.md\"]\nDepth = 1","category":"page"},{"location":"index.html#Functions","page":"BosonSampling.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"Pages = [\"bunching.md\", \"samplers.md\"]\nDepth = 1","category":"page"},{"location":"types/type_functions.html","page":"type utilities","title":"type utilities","text":"Modules = [BosonSampling]\nPages = [\"type_functions.jl\"]\nPrivate = false","category":"page"},{"location":"types/type_functions.html#BosonSampling.get_parametric_type-Tuple{Any}","page":"type utilities","title":"BosonSampling.get_parametric_type","text":"get_parametric_type(i)\n\nReturn the types T1,..,Tn of a parametric type i::T{T1,..,Tn}.\n\nnote: Note\nIf the parametric type has only one parameter, use get_parametric_type(i)[1].\nIf no parametric type, returns an array containing the type itself.\n\n\n\n\n\n","category":"method"}]
}
